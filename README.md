# caro-checker

## Demo

```javascript
const cc = required('caro-checker')

const input = {name: 'Caro123', pwd: 'caro_123', checkPwd: 'caro_123', age: '18'}

const info = await cc.object({
  name: cc.string().min(6).max(30).required(), // a required string and it's length should be between 6~30
  pwd: cc.string().min(6).max(12).required(), // a required string and it's length should be between 6~12
  checkPwd: cc.ref('pwd'), // it's value should equal to pwd
  age: cc.number().min().max(120).required(), // a required number between 1~120
  isStudent: cc.boolean().default(false), // a boolean defaults to false
}).note('for account registration').parse(input)

/*
info = {
  schema: 'ObjectSchema', // the running schema
  input: {name: 'Caro123', pwd: 'caro_123', checkPwd: 'caro_123', age: 18, isStudent: false}, // the input value after parsing
  rule: 'object', // the last done rule during parsing
  route: 'isStudent', // the last route during parsing
  error: undefined, // the message while an error occurred
  note: 'for account registration', // additional note
}
*/
```

## Introduction

```text
This is a plugin inspired by https://joi.dev/ but only supports String/Number/Boolean/Object/Array type validations.
It only includes some basic validations but supports more simplified logic for extensions.
```

## Definition of terms

- rule - each stage during validation
- plan - a regulation for object-type validation
- enums - the valid values for any-type and array-type validations
- route - indicate wherein the value is, for array-type and object-type validations
- schema - an instance generated by caro-check, for particular input-type validations
- helper - an extended schema in rule-function for advanced operations
- ref - an instance referring to a value by an assigned route, functioning in a plan for object-type validation

---

## caroChecker

### ref(route)

```javascript
// get value by assigned object-route | 支援取得指定欄位的值
// return *

const info = await cc.object({
  a: {b: cc.any()},
  c: {d: cc.ref('a.b')},
}).parse({a: {b: 3}, c: {d: 6}})

// info.route = 'c.d'
// info.error = 'd only accepts 3'
```

### isRef(arg)

```javascript
// to check if it's a reference | 檢查是否為 ref 物件
// return Boolean

cc.isRef(cc.ref('a')) // true
cc.isRef({}) // false
```

### isSchema(arg, type = undefined)

```javascript
// to check if it's a schema | 檢查是否為 schema 物件
// return Boolean

cc.isSchema(cc.object()) // true
cc.isSchema({}) // false
```

---

## caroChecker.any

### any([...enums])

```javascript
// accept any value | 允許輸入值為任何格式
// return schema

const info = await cc.any().parse(1)

// info.error = undefined
```

```javascript
// only allow specific values | 檢查輸入值為指定值

const info = await cc.any(cc.string(), 3, undefined).parse(4)

// info.error = 'the input only accepts String or 3 or undefined'
```

### any().getInfo()

```javascript
// get info of the schema | 取得 schema 資訊
// return Object

const info = await cc.any().getInfo()

/*
info = {
  schema: 'AnySchema', // the running schema
  input: undefined, // the input value
  rule: undefined, // the last running rule when parsing
  route: '', // the last object-route when parsing an object
  error: undefined, // the message while an error occurred
  note: undefined, // additional note
}
*/
```

### any().getDetail()

```javascript
// get detail of the schema | 取得 schema 詳細資訊
// return Object

const info = await cc.any().getDetail()

/*
info = {
  ... // fields that same as .getInfo()
  type: 'Any', // validation type
  isCustomSkip: false, // if the "skip" property is been set
  isCustomLabel: false, // if the "label" property is been set
  label: 'the input', // the display name in the error message
  warning: undefined, // the custom error message
  default: undefined,  // the default value when the input is undefined
  required: false, // the property to define if the input value is required (not undefined)
  preRules: {}, // the information shows pre-rules
  mainRules: { default: [Function (anonymous)], require: [Function (anonymous)] },  // the information shows main-rules
  postRules: { any: [AsyncFunction (anonymous)] },  // the information shows post-rules
  skip: false, // the property that define if the validation is skipped
  input: undefined, // the input value
  doneRules: [], // the rules that are done
  dismissalRules: [], // the rules that are dismissed because an error occurred
  skipRules: [], // the rules that are skipped
  ... // other fields for particular information
}
*/
```

### any().parse(input, [boolean = false])

```javascript
// start a validation process for input value and return information | 執行驗證流程
// return Object

await cc.any().parse('input') // validate and return information same as schema.getInfo()
await cc.any().parse('input', true) // validate and return information same as schema.getDetail()
```

### any().getType()

```javascript
// get checking type | 取得檢查類型
// return string

cc.any().getType() // 'Any'
cc.string().getType() // 'String'
```

### any().getInput()

```javascript
// get input value while parsing | 取得解析時的輸入值
// return string

const schema = cc.any()

await schema.parse('gg')

schema.getInput() // 'gg'
```

### any().required([boolean = true]).getRequired()

```javascript
// set and get the "required" property - the validation will stop and set an error message during parsing a undefined value | 設置並取得"是否必填"屬性
// return string

cc.any().required().getRequired() // true

const info = await cc.any().required().parse(undefined)

// info.error = 'the input is required'
```

### any().skip([boolean = true]).getSkip()

```javascript
// set and get "skip" property - the validation will be skipped when it's true | 設置並取得"是否跳過檢查"屬性
// return string

cc.any().skip().getSkip() // true

const info = await cc.any().skip().required().parse(undefined)

// info.error = undefined
```

### any().default(value).getDefault()

```javascript
// set and get a default value | 設置及取得預設值
// return string

const def = 'defaultValue'

cc.any().default(def).getDefault() // 'defaultValue'

const info = await cc.any().default(def).parse(undefined)

// info.input = 'defaultValue'
```

### any().label(string).getLabel()

```javascript
// set and get a label - it will replace the title in error message | 設置並取得標籤
// return string

const lab = 'caro'

cc.any().label(lab).getLabel() // 'caro'

const info = await cc.any().label(lab).required().parse(undefined)

// info.error = 'caro is required'
```

### any().warning(string).getWarning()

```javascript
// set and get a warning message - it will replace the default error message | 設置並取得警告訊息
// return string

const warn = 'something went wrong'

cc.any().warning(warn).getWarning() // 'something went wrong'

const info = await cc.any().warning(warn).required().parse(undefined)

// info.error = 'something went wrong'
```

### any().note(string).getNote()

```javascript
// set and get a note - for any additional information | 設置並取得註解
// return string

cc.any().note('this is note').getNote() // 'this is note'
```

### any().insertPre(function, [string = 'insertPre'])

```javascript
// insert a rule before type-validation | 設置前置規則
// return schema

const info = await cc.any().insertPre((helper) => {
  const value = helper.getInput() // 'input'
}, 'customFn').parse('input', true)

// info.doneRules = [ 'customFn', 'default', 'require', 'any' ]
```

### any().insertPost(function, [string = 'insertPost'])

```javascript
// insert a rule after type-validation | 設置後置規則
// return schema

const info = await cc.any().insertPost((helper) => {
  const input = helper.getInput() // 'input'
}, 'customFn').parse('input', true)

// info.doneRules = ['default', 'require', 'any', 'customFn']
```

### any().allow(...enums)

```javascript
// confine the input value | 限定輸入值
// return schema

const input = 3
const info = await cc.any().allow(1, cc.string()).parse(input)

// info.error = 'the input only accepts 1 or String'
```

### any().forbid(...enums)

```javascript
// forbid specific values | 不允許特定值
// return schema

const input = 3
const info = await cc.any().forbid(1, cc.string()).parse(input)

// info.error = 'the input cannot be 1 or String'
```

---

## caroChecker.string

### string()

```javascript
// check if the input value is a String | 檢查輸入值為字串
// return schema

const info = await cc.string().parse(123)

// info.error = 'the input only accepts String'
```

### string().size([limit = 1]

```javascript
// check the size of String | 檢查字串長度
// return schema

const info = await cc.string().size(3).parse('1')

// info.error = 'the input size should be 3'
```

### string().min([limit = 1])

```javascript
// check if the String's size is equal to or greater than the specific length | 檢查字串最小長度
// return schema

const info = await cc.string().min(3).parse('12')

// info.error = 'the input size cannot be less than 3'
```

### string().max([limit = 1])

```javascript
// check if the String's size is equal to or less than the specific length | 檢查字串最大長度
// return schema

const info = await cc.string().max(3).parse('1234')

// info.error = 'the input size cannot be greater than 3'
```

---

## caroChecker.number

### number()

```javascript
// check if the input value is a Number | 檢查輸入值為數字
// return schema

// Note. it also accepts a numeric string by default and will convert it into a number
const info = await cc.number().parse('123')

// info.input = 123
// info.error = undefined
```

```javascript
// strict validation
const info = await cc.number().strict().parse('123')

// info.error = 'the input only accepts Number'
```

```javascript
const info = await cc.number().parse('str')

// info.error = 'the input only accepts Number'
```

### number().min([limit = 1], [exclude = false])

```javascript
// check if the input value is equal to or greater than the specific number | 檢查數字最小值
// return schema

const info = await cc.number().min(3).parse(3)

// info.error = 'the input should be equal to or greater than 3'
```

```javascript
const info = await cc.number().min(3, true).parse(3)

// info.error = 'the input should be greater than 3'
```

### number().max([limit = 1], [exclude = false])

```javascript
// check if the input value is equal to or less than the specific number | 檢查數字最大值
// return schema

const info = await cc.number().max(3).parse(4)

// info.error = 'the input should be equal to or less than 3'
```

```javascript
const info = await cc.number().max(3, true).parse(3)

// info.error = 'the input should be less than 3'
```

---

## caroChecker.boolean

### boolean()

```javascript
// check if the input value is a Boolean | 檢查輸入值為布林值
// return schema

// Note. also support ('true', '1', 1) to true and ('false', '0', 0) to false
const info = await cc.boolean().parse('true')

// info.input = true
// info.error = undefined
```

```javascript
// strict validation
const info = await cc.boolean().strict().parse('true')

// info.error = 'the input only accepts Boolean'
```

```javascript
const info = await cc.boolean().parse('str')

// info.error = 'the input only accepts Boolean'
```

---

## caroChecker.array

### array([...enums])

```javascript
// check if the input value is an Array | 檢查輸入值為陣列
// return schema

const info = await cc.array().parse([undefined])

// info.error = undefined
```

```javascript
// only allow specific values in the array | 檢查陣列元素為指定值

const info = await cc.array(cc.object({name: cc.string().required()})).parse([{name: 'a'}, {name: 'b'}])

// info.error = undefined
```

```javascript
const info = await cc.array(cc.object({name: cc.string().required()})).parse([{name: 'a'}, undefined])

// info.route = '1'
// info.error = 'the array-element in the input only accepts Object'
```

```javascript
const info = await cc.array(cc.string(), cc.number(), cc.object(), true).parse(['str', 3, {}, false])

// info.route = '3'
// info.error = 'the array-element in the input only accepts String or Number or Object or true'
```

---

## caroChecker.object

### object([plan-object])

```javascript
// check if the input value is an Object | 檢查輸入值為物件
// return schema

const info = await cc.object().parse({})

// info.input = {}
// info.error = undefined
```

```javascript
// check if the input value matches with plan-object | 檢查輸入值為物件, 且符合規格表定義

const info = await cc.object({
  num: cc.number().required(),
  obj: {}, // equals to cc.object({}).required()
  onlyVal: 1, // equals to cc.any(1).required()
  enumVal: [cc.string(), cc.ref('num')], // equals to cc.any(cc.string(), cc.ref('num')).required()
}).parse({
  num: '18', // Note. this will convert to 18 after parsing
  obj: {}, onlyVal: 1, enumVal: 18,
})

// info.input = {num: 18, obj: {}, onlyVal: 1, enumVal: 18}
// info.error = undefined
```

```javascript
const info = await cc.object().parse('str')

// info.error = 'the input only accepts Object'
```

```javascript
const info = await cc.object({
  name: cc.string().required(),
  age: cc.number().required(),
  addr: cc.string().required(),
}).parse({name: 'caro', age: 'age12'})

// info.input = {name: 'caro', age: 'age12'}
// info.route = 'age'
// info.error = 'age only accepts Number'
```

### object().size([limit = 1]

```javascript
// check the Object's size | 檢查物件長度
// return schema

const info = await cc.object().size(3).parse({a: 1})

// info.error = 'the input size should be 3'
```

### object().min([limit = 1])

```javascript
// check if the Object's size is equal to or greater than the specific length | 檢查物件最小長度
// return schema

const info = await cc.object().min(3).parse({a: 1})

// info.error = 'the input size cannot be less than 3'
```

### object().max([limit = 1])

```javascript
// check if the Object's size is equal to or less than the specific length | 檢查物件最大長度
// return schema

const info = await cc.object().max(3).parse({a: 1, b: 2, c: 3, d: 4})

// info.error = 'the input size cannot be greater than 3'
```

---

## Examples for custom schema

```javascript
// define a schema that auto-trim the input string | 定義[可以自動移除字串前後空白]的 string-schema

cc.trimStr = () => {
  return cc.string().insertPre((helper) => {
    const input = helper.getInput()

    if (!_.isString(input)) return

    return helper.input(input.trim())
  }, 'trimStr')
}

const info = await cc.trimStr().parse(' caro ')

// info.input = 'caro'
```

```javascript
// define a schema that could convert string to array | 定義[支援字串轉陣列]的 array-schema

cc.arrayLike = ({separator = ',', toNum = false} = {}) => {
  return cc.array().insertPre((helper) => {
    let input = helper.getInput()

    helper.warning(`{#label#} input only accepts array or array-like string`)

    if (!_.isString(input)) return

    const arr = input.split(separator).map((v) => {
      v = v.trim()
      if (toNum) v = Number(v)
      return v
    })
    helper.input(arr)
  }, 'arrayLike')
}

const info = await cc.arrayLike({separator: ';', toNum: true}).parse('1;2;3')

// info.input = [1, 2, 3]
```

---

## Examples for custom extension

```javascript
// print out input value before input-type validation for all schemas

cc.preRule.printInput = (helper) => {
  const input = helper.getInput()
  console.log(`Validating input value: ${input}`)
}

await cc.any().printInput().parse(1)
await cc.string().printInput().parse('caro')
```

```javascript
// print out info after input-type validation for all schemas

cc.postRule.printInfo = (helper) => {
  const info = helper.getInfo()
  console.log(`Got validation info: ${info}`)
}

await cc.number().printInfo().parse(1)
await cc.boolean().printInfo().parse(true)
```

```javascript
// check if a string is numerical for string-schema | 定義一個[檢查是否為數字格式]的 string-schema

cc.string.postRule.numeric = (helper) => {
  if (!Number.isNaN(Number(helper.getInput()))) return
  helper.markError(`{#label#} should be numerical`)
}

const info = await cc.string().numeric().parse('caro123')

// info.error = 'the input should be numerical'
```

```javascript
// check if a string is alphanumeric for string-schema | 定義一個[檢查是否為英文數字格式]的 string-schema

cc.string.postRule.alphanumeric = (helper, {symbol = '', alphaMin, numberMin} = {}) => {
  const escapeSymbol = symbol.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&')

  alphaMin = helper.extractRef(alphaMin) || 1
  numberMin = helper.extractRef(numberMin) || 1

  let re = new RegExp(`[^a-zA-Z0-9${escapeSymbol}]`, 'g')
  let errMsg = `{#label#} only accepts English letters${symbol ? ', ' : ' and '}numbers${symbol ? `, and "${symbol}"` : ''}`

  const input = helper.getInput()

  if (input.match(re)) return helper.markError(errMsg)

  if (alphaMin > 0) {
    re = new RegExp(`[a-zA-Z]{${alphaMin},}`, 'g')
    if (!input.match(re)) {
      errMsg = `{#label#} should include at least ${alphaMin} letter${alphaMin > 1 ? 's' : ''}`
      return helper.markError(errMsg)
    }
  }
  if (numberMin > 0) {
    re = new RegExp(`[0-9]{${numberMin},}`, 'g')
    if (!input.match(re)) {
      errMsg = `{#label#} should include at least ${alphaMin} number${numberMin > 1 ? 's' : ''}`
      return helper.markError(errMsg)
    }
  }
}

const info = await cc.string().alphanumeric({symbol: '_'}).parse('caro.123')

// info.error = 'the input only accepts letters, numbers, and "_"'
```

```javascript
// check email for string-schema | 定義一個[檢查 email 格式]的 string-schema

cc.string.postRule.email = (helper) => {
  const re = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/
  if (String(helper.getInput()).toLowerCase().match(re)) return
  helper.markError(`{#label#} should be an email`)
}

const info = await cc.string().email().parse('caro@email@com')

// info.error = 'the input should be an email'
```

```javascript
// check integer for number-schema | 定義一個[檢查整數]的 number-schema

cc.number.postRule.integer = (helper) => {
  if (helper.getInput() % 1 === 0) return
  helper.markError('{#label#} only accepts Integer')
}

const info = await cc.number().integer().parse(1.1)

// info.error = 'the input only accepts Integer'
```

```javascript
// check float for number-schema | 定義一個[檢查浮點數]的 number-schema

cc.number.postRule.float = (helper) => {
  if (helper.getInput() % 1 !== 0) return
  helper.markError(`{#label#} input only accepts float`)
}

const info = await cc.number().integer().parse(1)

// info.error = 'the input only accepts Float'
```

```javascript
// define a key-set that should present together or not | 定義[指定欄位需同時存在或不存在]的 object-schema

cc.object.postRule.together = (helper, ...settings) => {
  const input = helper.getInput()
  const allKeys = Object.keys(input)

  for (let {keys, warning} of settings) {
    helper.note(`${keys.join(',')}`)

    const firstKey = keys[0]
    const firstHasKey = allKeys.includes(firstKey)

    let errField = ''
    for (const field of keys) {
      const hasKey = allKeys.includes(field)
      if (firstHasKey && hasKey) continue
      if (!firstHasKey && !hasKey) continue
      errField = field
    }

    if (!errField) continue

    if (!warning) warning = `${keys.join(', ')} should present together`

    helper.markError(warning)
    break
  }
}

const settings = [
  {keys: ['a', 'b']},
]
const info = await cc.object().together(...settings).parse({a: true})

// assert.strictEqual(info.note, `a,b`)
// assert.strictEqual(info.error, `a, b should present together`)
```

```javascript
// define how many should exist in a specific key set | 定義[指定欄位中需要存在的數量]的 object-schema

cc.object.postRule.scoop = (helper, ...settings) => {
  const {plan} = helper.getDetail()
  const input = helper.getInput()

  for (const k in input) {
    if (input[k] === undefined) delete input[k]
  }

  const inputKeys = Object.keys(input)
  const defKeys = Object.keys(plan) || inputKeys

  for (let {keys = defKeys, min = 1, max = keys.length, warning} of settings) {
    const amount = keys.length
    let keyCount = 0

    min = helper.extractRef(min) || 1
    max = max === true ? keys.length : (helper.extractRef(max) || 1)

    if (min < 1) min = 1
    else if (min > amount) min = amount

    if (max < 1) max = 1
    else if (max > amount) max = amount

    if (max < min) max = min

    helper.note(keys.join(','))

    for (const key of keys) {
      if (inputKeys.includes(key)) keyCount++
    }

    if (keyCount >= min && keyCount <= max) continue

    if (!warning) {
      const beVerb = min === max && min === 1 ? `is` : `are`
      const range = min === max ? `${min}` : `${min}~${max}`
      const among = amount > 2 ? `among` : `between`
      warning = `there ${beVerb} ${range} required ${among} ${keys.join(', ')}`
    }

    helper.markError(warning)
    break
  }
}

const plan = {a: boolean(), b: boolean(), c: boolean()}
const settings = [{
  keys: ['a', 'b'], // default = plan's or input's keys
  min: 1, // limit the minimum amount for keys; default = 1
  max: 1, // limit the maximum amount for keys, default = keys.length
  // warning: 'custom msg',
}]
const info = await cc.object(plan).scoop(...settings).parse({c: true})

// info.note = 'a,b'
// info.error = 'there is 1 required between a, b'
```

## Other applications

```test
Please check out the file /test/_application.js on github
```
